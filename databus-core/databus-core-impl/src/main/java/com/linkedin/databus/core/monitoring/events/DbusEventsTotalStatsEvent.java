/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */
package com.linkedin.databus.core.monitoring.events;
/*
 *
 * Copyright 2013 LinkedIn Corp. All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
*/


@SuppressWarnings("all")
/** Total inbound or outbound databus events statistics */
public class DbusEventsTotalStatsEvent extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = org.apache.avro.Schema.parse("{\"type\":\"record\",\"name\":\"DbusEventsTotalStatsEvent\",\"namespace\":\"com.linkedin.databus.core.monitoring.events\",\"fields\":[{\"name\":\"ownerId\",\"type\":\"int\",\"doc\":\"The id of the owner that generated the event\"},{\"name\":\"timestampLastResetMs\",\"type\":\"long\",\"doc\":\"unix timestamp of the last reset() call\"},{\"name\":\"timeSinceLastResetMs\",\"type\":\"long\",\"doc\":\"time in ms since the last reset() call\"},{\"name\":\"dimension\",\"type\":\"string\",\"doc\":\"dimension\"},{\"name\":\"numDataEvents\",\"type\":\"long\",\"doc\":\"number of data events scanned\"},{\"name\":\"sizeDataEvents\",\"type\":\"long\",\"doc\":\"size of data events scanned  (metadata and payload)\"},{\"name\":\"sizeDataEventsPayload\",\"type\":\"long\",\"doc\":\"size of the payload of data events scanned\"},{\"name\":\"numSysEvents\",\"type\":\"long\",\"doc\":\"number of system events scanned\"},{\"name\":\"sizeSysEvents\",\"type\":\"long\",\"doc\":\"size of system events scanned (metadata and payload)\"},{\"name\":\"numDataEventsFiltered\",\"type\":\"long\",\"doc\":\"number of data events that were streamed out after filtering\"},{\"name\":\"sizeDataEventsFiltered\",\"type\":\"long\",\"doc\":\"size of data events (metadata and payload) that were streamed out after filtering\"},{\"name\":\"sizeDataEventsPayloadFiltered\",\"type\":\"long\",\"doc\":\"size of the payload of data events that were streamed out after filtering\"},{\"name\":\"numPeers\",\"type\":\"int\",\"doc\":\"number of distinct peers that have connected\"},{\"name\":\"minSeenWinScn\",\"type\":\"long\",\"doc\":\"the minimum requested window scn scanned or received\"},{\"name\":\"maxSeenWinScn\",\"type\":\"long\",\"doc\":\"the maximum requested window scn scanned or received\"},{\"name\":\"maxFilteredWinScn\",\"type\":\"long\",\"doc\":\"the maximum requested window scn sent out after filtering\"},{\"name\":\"numInvalidEvents\",\"type\":\"long\",\"doc\":\"number of invalid events\"},{\"name\":\"numErrHeader\",\"type\":\"long\",\"doc\":\"number of invalid events with  header error\"},{\"name\":\"numErrPayload\",\"type\":\"long\",\"doc\":\"number of invalid events with payload error\"},{\"name\":\"timestampCreated\",\"type\":\"long\",\"doc\":\"unix timestamp of creation of buffer\"},{\"name\":\"timestampAccessed\",\"type\":\"long\",\"doc\":\"unix timestamp of last access\"},{\"name\":\"timestampMinScnEvent\",\"type\":\"long\",\"doc\":\"unix timestamp of first event of minScn\"},{\"name\":\"timestampMaxScnEvent\",\"type\":\"long\",\"doc\":\"unix timestamp of last event of maxScn\"},{\"name\":\"latencyEvent\",\"type\":\"long\",\"doc\":\"time in ms since generation of event\"},{\"name\":\"minWinScn\",\"type\":\"long\",\"doc\":\"the minimum window scn in memory\"},{\"name\":\"maxWinScn\",\"type\":\"long\",\"doc\":\"the maximum windown scn in memory\"},{\"name\":\"sinceWinScn\",\"type\":\"long\",\"doc\":\"the scn immediately preceding minScn in memory \"},{\"name\":\"numFreeBytes\",\"type\":\"long\",\"doc\":\"Free space in bytes available in buffer \"},{\"name\":\"maxTimestampAccessed\",\"type\":\"long\",\"doc\":\"Aggregated: Max of timestampAccessed amongst all buffers \"},{\"name\":\"minTimestampAccessed\",\"type\":\"long\",\"doc\":\"Aggregated: Min of timestampAccessed amongst all buffers \"},{\"name\":\"maxTimeSpan\",\"type\":\"long\",\"doc\":\"Aggregated: Max of getTimeSpan amongst all buffers \"},{\"name\":\"minTimeSpan\",\"type\":\"long\",\"doc\":\"Aggregated: Min of getTimeSpan amongst all buffers \"},{\"name\":\"maxTimestampMaxScnEvent\",\"type\":\"long\",\"doc\":\"Aggregated: Max of timestampMaxScnEvent amongst all buffers \"},{\"name\":\"minTimestampMaxScnEvent\",\"type\":\"long\",\"doc\":\"Aggregated: Min of timestampMaxScnEvent amongst all buffers \"},{\"name\":\"timeLag\",\"type\":\"long\",\"doc\":\"difference between maxScn event gen time and access/add time\"},{\"name\":\"maxTimeLag\",\"type\":\"long\",\"doc\":\"Aggregated: Max of timeLag amongst all buffers\"},{\"name\":\"minTimeLag\",\"type\":\"long\",\"doc\":\"Aggregated: Min of timeLag amongst all buffers\"}]}");
  /** The id of the owner that generated the event */
  public int ownerId;
  /** unix timestamp of the last reset() call */
  public long timestampLastResetMs;
  /** time in ms since the last reset() call */
  public long timeSinceLastResetMs;
  /** dimension */
  public java.lang.CharSequence dimension;
  /** number of data events scanned */
  public long numDataEvents;
  /** size of data events scanned  (metadata and payload) */
  public long sizeDataEvents;
  /** size of the payload of data events scanned */
  public long sizeDataEventsPayload;
  /** number of system events scanned */
  public long numSysEvents;
  /** size of system events scanned (metadata and payload) */
  public long sizeSysEvents;
  /** number of data events that were streamed out after filtering */
  public long numDataEventsFiltered;
  /** size of data events (metadata and payload) that were streamed out after filtering */
  public long sizeDataEventsFiltered;
  /** size of the payload of data events that were streamed out after filtering */
  public long sizeDataEventsPayloadFiltered;
  /** number of distinct peers that have connected */
  public int numPeers;
  /** the minimum requested window scn scanned or received */
  public long minSeenWinScn;
  /** the maximum requested window scn scanned or received */
  public long maxSeenWinScn;
  /** the maximum requested window scn sent out after filtering */
  public long maxFilteredWinScn;
  /** number of invalid events */
  public long numInvalidEvents;
  /** number of invalid events with  header error */
  public long numErrHeader;
  /** number of invalid events with payload error */
  public long numErrPayload;
  /** unix timestamp of creation of buffer */
  public long timestampCreated;
  /** unix timestamp of last access */
  public long timestampAccessed;
  /** unix timestamp of first event of minScn */
  public long timestampMinScnEvent;
  /** unix timestamp of last event of maxScn */
  public long timestampMaxScnEvent;
  /** time in ms since generation of event */
  public long latencyEvent;
  /** the minimum window scn in memory */
  public long minWinScn;
  /** the maximum windown scn in memory */
  public long maxWinScn;
  /** the scn immediately preceding minScn in memory  */
  public long sinceWinScn;
  /** Free space in bytes available in buffer  */
  public long numFreeBytes;
  /** Aggregated: Max of timestampAccessed amongst all buffers  */
  public long maxTimestampAccessed;
  /** Aggregated: Min of timestampAccessed amongst all buffers  */
  public long minTimestampAccessed;
  /** Aggregated: Max of getTimeSpan amongst all buffers  */
  public long maxTimeSpan;
  /** Aggregated: Min of getTimeSpan amongst all buffers  */
  public long minTimeSpan;
  /** Aggregated: Max of timestampMaxScnEvent amongst all buffers  */
  public long maxTimestampMaxScnEvent;
  /** Aggregated: Min of timestampMaxScnEvent amongst all buffers  */
  public long minTimestampMaxScnEvent;
  /** difference between maxScn event gen time and access/add time */
  public long timeLag;
  /** Aggregated: Max of timeLag amongst all buffers */
  public long maxTimeLag;
  /** Aggregated: Min of timeLag amongst all buffers */
  public long minTimeLag;
  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call.
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return ownerId;
    case 1: return timestampLastResetMs;
    case 2: return timeSinceLastResetMs;
    case 3: return dimension;
    case 4: return numDataEvents;
    case 5: return sizeDataEvents;
    case 6: return sizeDataEventsPayload;
    case 7: return numSysEvents;
    case 8: return sizeSysEvents;
    case 9: return numDataEventsFiltered;
    case 10: return sizeDataEventsFiltered;
    case 11: return sizeDataEventsPayloadFiltered;
    case 12: return numPeers;
    case 13: return minSeenWinScn;
    case 14: return maxSeenWinScn;
    case 15: return maxFilteredWinScn;
    case 16: return numInvalidEvents;
    case 17: return numErrHeader;
    case 18: return numErrPayload;
    case 19: return timestampCreated;
    case 20: return timestampAccessed;
    case 21: return timestampMinScnEvent;
    case 22: return timestampMaxScnEvent;
    case 23: return latencyEvent;
    case 24: return minWinScn;
    case 25: return maxWinScn;
    case 26: return sinceWinScn;
    case 27: return numFreeBytes;
    case 28: return maxTimestampAccessed;
    case 29: return minTimestampAccessed;
    case 30: return maxTimeSpan;
    case 31: return minTimeSpan;
    case 32: return maxTimestampMaxScnEvent;
    case 33: return minTimestampMaxScnEvent;
    case 34: return timeLag;
    case 35: return maxTimeLag;
    case 36: return minTimeLag;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call.
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: ownerId = (java.lang.Integer)value$; break;
    case 1: timestampLastResetMs = (java.lang.Long)value$; break;
    case 2: timeSinceLastResetMs = (java.lang.Long)value$; break;
    case 3: dimension = (java.lang.CharSequence)value$; break;
    case 4: numDataEvents = (java.lang.Long)value$; break;
    case 5: sizeDataEvents = (java.lang.Long)value$; break;
    case 6: sizeDataEventsPayload = (java.lang.Long)value$; break;
    case 7: numSysEvents = (java.lang.Long)value$; break;
    case 8: sizeSysEvents = (java.lang.Long)value$; break;
    case 9: numDataEventsFiltered = (java.lang.Long)value$; break;
    case 10: sizeDataEventsFiltered = (java.lang.Long)value$; break;
    case 11: sizeDataEventsPayloadFiltered = (java.lang.Long)value$; break;
    case 12: numPeers = (java.lang.Integer)value$; break;
    case 13: minSeenWinScn = (java.lang.Long)value$; break;
    case 14: maxSeenWinScn = (java.lang.Long)value$; break;
    case 15: maxFilteredWinScn = (java.lang.Long)value$; break;
    case 16: numInvalidEvents = (java.lang.Long)value$; break;
    case 17: numErrHeader = (java.lang.Long)value$; break;
    case 18: numErrPayload = (java.lang.Long)value$; break;
    case 19: timestampCreated = (java.lang.Long)value$; break;
    case 20: timestampAccessed = (java.lang.Long)value$; break;
    case 21: timestampMinScnEvent = (java.lang.Long)value$; break;
    case 22: timestampMaxScnEvent = (java.lang.Long)value$; break;
    case 23: latencyEvent = (java.lang.Long)value$; break;
    case 24: minWinScn = (java.lang.Long)value$; break;
    case 25: maxWinScn = (java.lang.Long)value$; break;
    case 26: sinceWinScn = (java.lang.Long)value$; break;
    case 27: numFreeBytes = (java.lang.Long)value$; break;
    case 28: maxTimestampAccessed = (java.lang.Long)value$; break;
    case 29: minTimestampAccessed = (java.lang.Long)value$; break;
    case 30: maxTimeSpan = (java.lang.Long)value$; break;
    case 31: minTimeSpan = (java.lang.Long)value$; break;
    case 32: maxTimestampMaxScnEvent = (java.lang.Long)value$; break;
    case 33: minTimestampMaxScnEvent = (java.lang.Long)value$; break;
    case 34: timeLag = (java.lang.Long)value$; break;
    case 35: maxTimeLag = (java.lang.Long)value$; break;
    case 36: minTimeLag = (java.lang.Long)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
}
